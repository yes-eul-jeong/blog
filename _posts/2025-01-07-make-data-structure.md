---
layout: post
title: "데이터 구조"
date: 2025-01-07 03:07:45 +0900
tags: [ study, 기초 ]
categories: []
---


## 데이터 구조 만들기

### ID
각 데이터의 배열, 객체에는 식별할 수 있는 primary key가 필요함. primary key를 만드는 방법엔 여러 가지가 있다.

  - **자동증가**: 가장 큰 ID에 1을 더해 새로운 ID 부여.
  - **UUID 사용**: Universally Unique Identifier, 128비트의 고유 식별자 생성. JS로 생성 가능.

  
  > *보안 Tip
  >**DB에서 고유번호를 일련번호로 하면 안되는 이유?**
  >- **보안 문제**: 예측이 가능함. 외부에서 임의의 숫자를 입력하여 접근이 가능할 수 있을 뿐더러 데이터 생성 순서 및 양을 예측이 가능함.



### 생성일
데이터 생성 날짜, 필터링에 사용 가능하며 `new Date()`가 아닌 `Date.now()`를 사용하면 timestamp로 저장하므로 호환성이 좋은 숫자형 타입값이 된다. 또한 `new Date()` 작성할 시 데이터 타입이 객체이므로 DB에 저장이 불가능함. mysql 기준 가장 좋은 날짜 저장 방식은 timestamp다, timestamp로 저장하면 10자리 unixtimestamp를 이용하면서 동시에 Ymdhis 형식으로도 보여질 수 있다. 이는 상황에 따라 유연하게 timezone을 적용할 수도 있게 된다. 속도도 좋다. 암튼 짱이다. 다만 시간정보까지 필요가 없다면 date형식(Ymd)만 써도 된다.

  > **왜 DB 저장이 안될까?** 
  > - Date 객체는 통신 시 JSON 형식으로 직렬화되는데, JSON은 js 전용 객체(ex, Date, Symbol..) 지원을 안함. 단순한 배열/객체/원시값만 가능.
>   
  > *어라? 난 DB저장 했는데?*
> 
  > - ~~좋겠다.~~
  > - DB에 따라 비정형화된 정보를 저장할 수 있는 DB(NoSQL)가 있음 (ex: MongoDB)


### Log Data와 Vector Data은 nosql이 선호됨
1. logData
- 시스템 혹은 애플리케이션에서 발생하는 이벤트나 활동을 기록한 데이터.
- 주로 시간순으로 기록되며, 디버깅, 모니터링, 분석등에 사용
2. vector Data
- 주로 GIS(지리 정보 시스템)에 사용되는 데이터 형식.
- 점, 선, 다각형 같은 기하학적 객체를 표현하는데 사용.
- 위치와 형태를 나타내는데 사용됨
- 지도, 공간분석에 활용됨. (도로, 강 건물 경계등)

***



### primarykey와 고유번호 그리고 고유 식별자

#### 1. Primary Key(기본 키) and 고유번호
  - **DB 테이블 내 각 레코드를 고유하게 식별**하는 column 혹은 column의 조합. 
  - 중복될 수 없으며 **NULL을 가질 수 없음. **
  - 보통 `id` 이름으로 씀
  - user테이블에서 user_id가 primary key가 될 수 있다. 
  - **인덱스**: 지정된 컬럼의 데이터를 따로 검색할 수 있도록 최적화하는 기능, 인덱스를 걸면 빨라지지만 추가/수정시와 용량의 비용이 증가한다.
    - **단일/복합**: 
      - 단일: 하나의 열로 구성된 키
      - 복합: 여러 열을 조합해서 만든 키
  - 특정 칼럼이 중복되지 않도록 보장하는 값. 
  - primary key와 비슷하지만 NULL값을 가질 수 있다. 
    - 그렇다고 NULL값을 고유하다고 인정하진 않는다.
  - 중복없이 유일해야함.
  - 반드시 숫자일 필요 없이 문자열의 형태로도 존재한다(제품코드, 주문번호...)
  - 필요에 따라 보안을 위해 예측불가하게 설계해야함. 노출되는 blog의 post number는 각 post의 고유번호지만 노출되도 무방하다.

**UUID** 같은 경우 일련번호가 아니기 때문에 몇억~몇백억 단위로 가면 *중복 문제* 생김. 그래서 충돌 문제 없애기 위해서는 *점점 길어질 수밖에 없는데*, 디비에서 값이 길어지면 인덱싱 용량이 폭발적으로 증가해서 다루기 힘듦. 그래서 이런 경우 **해시 컬럼**을 만들어서 해시 컬럼에만 인덱스를 주기도 함.



***



### Primitive Value
  - **Number**: 숫자. 정수와 실수를 포함. (42, 3.14)
  - **String**: 문자열. 텍스트 데이터를 나타냄.
  - **Boolean**: 논리. (true or false)
  - **Undefined**: 변수가 선언되었지만 값이 할당되지 않은 상태.
  - **Null**: 의도적으로 값이 없음을 나타내는 타입.
  - **Symbol**: 고유하고 변경 불가능한 값으로, 주로 객체의 프로퍼티 키.
  - **BigInt**: 임의의 정밀도를 가지는 정수 타입. 아주 큰 숫자를 다룰 때 사용
  - 
  >**Symbol과 BigInt**
  >비교적 최근에 추가된 데이터 타입.
  >BigInt는 길이의 제약 없이 정수를 다룰 때 사용된다. 
  >Symbol은 어떤 값과 비교해도 false가 나온다. 또한 숨겨져 있어 직접 언급하지 않으면 보이지 않음.
>
> → symbol도 true가 나올 수 있다?
>```
> const sym3 = Symbol('bar');
> const sym4 = sym3;
> 
> console.log(sym3 === sym4); // true
> ```
> → 그럼 이건?
>```
> const sym1 = Symbol('bar');
> const sym2 = Symbol('bar');
> 
> console.log(sym1 == sym2); // false
> ```
### Mutable (변경 가능)
  - **변경 가능**: mutable한 데이터는 생성된 후에도 그 값을 변경할 수 있어.
  - **예시**: JavaScript에서 객체(Object)와 배열(Array)은 mutable한 데이터 타입이야. 예를 들어, 배열에 새로운 요소를 추가하거나 객체의 프로퍼티 값을 변경할 수 있어.
  - **장점**: 데이터의 상태를 쉽게 변경할 수 있어서, 복잡한 데이터 구조를 다룰 때 유용해.
  - **단점**: 데이터가 변경될 수 있기 때문에, 예측하기 어려운 버그가 발생할 수 있어. 특히 여러 곳에서 같은 데이터를 참조할 때 주의해야 해.

### Immutable (변경 불가능)
  - **변경 불가능**: immutable한 데이터는 생성된 후에는 그 값을 변경할 수 없어.
  - **예시**: JavaScript에서 문자열(String)과 숫자(Number)는 immutable한 데이터 타입이야. 문자열을 변경하려면 새로운 문자열을 생성해야 해.
  - **장점**: 데이터가 변경되지 않기 때문에, 예측 가능한 코드를 작성할 수 있어. 특히 함수형 프로그래밍에서 유용해.
  - **단점**: 데이터를 변경하려면 새로운 데이터를 생성해야 하므로, 메모리 사용량이 늘어날 수 있어.


---

immer와 immutablejs에 대해 추가 정리가 필요하다!